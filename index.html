<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta charset="utf-8" />
<!-- Prevent caching during development -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>Fantastical Calendar</title>
<link rel="stylesheet" href="styles/globals.css?v=dev" />
<link rel="stylesheet" href="styles/styleguide.css?v=dev" />
	<!-- Roboto font -->
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&display=swap" rel="stylesheet">
	<!-- FullCalendar styles -->
	<link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.css" rel="stylesheet" />
	<!-- Supabase JS Client -->
	<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<!-- cache-bust style.css so edits show immediately -->
<link rel="stylesheet" href="styles/style.css?v=dev" />
<!-- Mini calendar overrides (loaded last to win cascade) -->
<link rel="stylesheet" href="styles/mini-calendar.css?v=dev" />
<!-- Todo list styles -->
<link rel="stylesheet" href="styles/todo-styles.css?v=dev" />
<!-- Chat styles -->
<link rel="stylesheet" href="styles/chat-styles.css?v=dev" />
<!-- Event modal styles -->
<link rel="stylesheet" href="styles/event-modal.css?v=dev" />
<!-- View button enhanced styles -->
<link rel="stylesheet" href="styles/view-button-styles.css?v=dev" />
</head>
<body>
<main class="fantastical">
<aside class="left-menu" role="complementary" aria-label="Calendar sidebar">
<header class="top">
<div class="div-2" style="display: flex; align-items: center; justify-content: space-between; width: 100%; padding: 0 16px;">
<div class="user-display" style="display: flex; flex-direction: column; align-items: flex-start; gap: 2px;">
<span style="font-size: 14px; font-weight: 600; color: #2d3748;">Loading...</span>
<span style="font-size: 12px; color: #a0aec0;"></span>
</div>
<div style="display: flex; align-items: center; gap: 8px;">
<button class="icon-button-master" aria-label="Sign out" id="logout-btn" title="Sign out">
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
<polyline points="16 17 21 12 16 7"></polyline>
<line x1="21" y1="12" x2="9" y2="12"></line>
</svg>
</button>
<button class="icon-button-master" aria-label="Add Todo" id="add-todo-btn" title="Add Todo" onclick="openTodoModal()">
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<line x1="12" y1="5" x2="12" y2="19"></line>
<line x1="5" y1="12" x2="19" y2="12"></line>
</svg>
</button>
</div>
</div>
</header>
<section class="date" aria-label="Calendar navigation">
<div class="div-3">
<h1 class="text-wrapper">February</h1>
<span class="text-wrapper-2">2021</span>
</div>
<div class="div-2">
<button class="img-2" aria-label="Previous month">
<img src="https://c.animaapp.com/mfytfryvOcjF0B/img/chevron-left.svg" alt="Previous" />
</button>
<button class="img-2" aria-label="Next month">
<img src="https://c.animaapp.com/mfytfryvOcjF0B/img/chevron-right.svg" alt="Next" />
</button>
</div>
</section>
<section class="mini-calendar" role="grid" aria-label="February 2021 mini calendar">
<div class="div-4" role="row">
<div class="day-header" role="columnheader"><div class="day">SUN</div></div>
<div class="day-header" role="columnheader"><div class="day">MON</div></div>
<div class="day-header" role="columnheader"><div class="day">TUE</div></div>
<div class="day-header" role="columnheader"><div class="day">WED</div></div>
<div class="day-header" role="columnheader"><div class="day">THU</div></div>
<div class="day-header" role="columnheader"><div class="day">FRI</div></div>
<div class="day-header" role="columnheader"><div class="day">SAT</div></div>
</div>
<div class="div-4" role="row">
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="January 31, 2021">31</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 1, 2021">1</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 2, 2021">2</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 3, 2021">3</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 4, 2021">4</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 5, 2021">5</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 6, 2021">6</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
</div>
<div class="div-4" role="row">
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 7, 2021">7</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 8, 2021">8</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 9, 2021">9</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 10, 2021">10</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 11, 2021">11</button>
<div class="event-dots-2" aria-hidden="true"><div class="dot-3"></div></div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 12, 2021">12</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 13, 2021">13</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
</div>
<div class="div-4" role="row">
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 14, 2021">14</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 15, 2021">15</button>
<div class="event-dots-2" aria-hidden="true"><div class="dot-2"></div></div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 16, 2021">16</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 17, 2021">17</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 18, 2021">18</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 19, 2021">19</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 20, 2021">20</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
</div>
<div class="div-4" role="row">
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 21, 2021">21</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 22, 2021">22</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 23, 2021">23</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 24, 2021">24</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 25, 2021">25</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 26, 2021">26</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="frame-wrapper" role="gridcell">
<div class="frame">
<button class="day-5" aria-label="February 27, 2021, today" aria-current="date">27</button>
<div class="event-dots-2" aria-hidden="true"><div class="dot-4"></div></div>
</div>
</div>
</div>
<div class="div-4" role="row">
<div class="day-2" role="gridcell">
<button class="day-4" aria-label="February 28, 2021">28</button>
<div class="event-dots-2" aria-hidden="true"><div class="dot"></div></div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 1, 2021">1</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 2, 2021">2</button>
<div class="event-dots-2" aria-hidden="true"><div class="dot-2"></div></div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 3, 2021">3</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 4, 2021">4</button>
<div class="event-dots-2" aria-hidden="true"><div class="dot-3"></div></div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 5, 2021">5</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 6, 2021">6</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
</div>
<div class="div-4" role="row">
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 7, 2021">7</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 8, 2021">8</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 9, 2021">9</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 10, 2021">10</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 11, 2021">11</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
<div class="dot-3"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 12, 2021">12</button>
<div class="event-dots-2" aria-hidden="true">
<div class="dot"></div>
<div class="dot-2"></div>
</div>
</div>
<div class="day-2" role="gridcell">
<button class="day-3" aria-label="March 13, 2021">13</button>
<div class="event-dots" aria-hidden="true">
<div class="dot"></div>
<div class="dot"></div>
<div class="dot"></div>
</div>
</div>
</div>
</section>
<section class="days-wrapper" aria-label="Upcoming events">
<div class="days">
<!-- Todos will be dynamically loaded here from database -->
</div>
</section>
</aside>
<section class="calendar-base" role="main" aria-label="Calendar main view">
<!-- Sidebar Toggle Button -->
<button class="sidebar-toggle" onclick="toggleSidebar()" aria-label="Toggle sidebar menu">
<span class="sidebar-toggle-icon">☰</span>
</button>
<!-- Right Menu Toggle Button -->
<button class="right-menu-toggle" onclick="toggleRightMenu()" aria-label="Toggle settings menu">
<span class="right-menu-toggle-icon">✕</span>
</button>
<header class="div-5">
<nav class="arrows" aria-label="Calendar navigation">
<div class="div-2">
<button class="icon-wrapper" aria-label="Previous week">
<img class="img" src="https://c.animaapp.com/mfytfryvOcjF0B/img/chevron-left.svg" alt="Previous" />
</button>
</div>
<button class="button" aria-label="Go to today">
<div class="button-master"><span class="text">Today</span></div>
</button>
<div class="div-2">
<button class="img-wrapper" aria-label="Next week">
<img class="img" src="https://c.animaapp.com/mfytfryvOcjF0B/img/chevron-right.svg" alt="Next" />
</button>
</div>
</nav>
<nav class="div-2" role="tablist" aria-label="Calendar view options">
<button class="button" role="tab" aria-selected="false">
<div class="button-master-2"><span class="text-2">Day</span></div>
</button>
<button class="button" role="tab" aria-selected="true">
<div class="button-master-3"><span class="text-wrapper-6">Week</span></div>
</button>
<button class="button" role="tab" aria-selected="false">
<div class="button-master-2"><span class="text-2">Month</span></div>
</button>
<button class="button" role="tab" aria-selected="false">
<div class="button-master-2"><span class="text-2">Year</span></div>
</button>
</nav>
<div class="field">
<div class="field-master">
<img class="img" src="https://c.animaapp.com/mfytfryvOcjF0B/img/icon-3.svg" alt="Search" />
<input class="search" placeholder="Search" type="text" aria-label="Search events" />
</div>
</div>
</header>
	<!-- mount point for FullCalendar -->
<div id="calendar" aria-label="Interactive calendar" role="region"></div>

</section>

<aside class="right-menu" role="complementary" aria-label="Settings sidebar">
<header class="top">
<div class="div-2">
<h5 div="ai-title">AI Assistant</h5>
</div>
</header>

<section class="chat-content" aria-label="Chat interface">
<div class="chat-messages" id="chat-messages">
<!-- Chat messages will appear here -->
</div>
<div class="chat-input-container">
<input type="text" id="chat-input" placeholder="Type a message..." class="chat-input" />
<button onclick="sendMessage()" class="chat-send-button">Send</button>
</div>
</section>
</aside>

<!-- Event Modal -->
<div id="event-modal" class="event-modal" style="display: none;">
<div class="event-modal-content">
<div class="event-modal-header">
<h2 id="modal-title">Event Details</h2>
<button class="modal-close" onclick="closeEventModal()">&times;</button>
</div>
<div class="event-modal-body">
<form id="event-form">
<input type="hidden" id="event-id" />
<div class="form-group">
<label for="event-title">Title *</label>
<input type="text" id="event-title" required placeholder="Event title" />
</div>
<div class="form-group">
<label for="event-description">Description</label>
<textarea id="event-description" rows="3" placeholder="Event description"></textarea>
</div>
<div class="form-row">
<div class="form-group">
<label for="event-start">Start Date/Time *</label>
<input type="datetime-local" id="event-start" required />
</div>
<div class="form-group">
<label for="event-end">End Date/Time *</label>
<input type="datetime-local" id="event-end" required />
</div>
</div>
<div class="form-row">
<div class="form-group">
<label for="event-location">Location</label>
<input type="text" id="event-location" placeholder="Meeting room, address, or link" />
</div>
<div class="form-group">
<label for="event-color">Color</label>
<input type="color" id="event-color" value="#3788d8" style="display: none;" />
<div class="color-dropdown">
<div class="color-dropdown-trigger" id="color-dropdown-trigger">
<div class="color-preview" id="color-preview" style="background-color: #3b82f6;"></div>
<span id="color-name">Blue</span>
<span class="color-dropdown-arrow">▼</span>
</div>
<div class="color-picker-grid" id="color-picker-grid">
<div class="color-option" data-color="#ef4444" data-name="Red" style="background-color: #ef4444;" title="Red"></div>
<div class="color-option" data-color="#f59e0b" data-name="Orange" style="background-color: #f59e0b;" title="Orange"></div>
<div class="color-option" data-color="#eab308" data-name="Yellow" style="background-color: #eab308;" title="Yellow"></div>
<div class="color-option" data-color="#22c55e" data-name="Green" style="background-color: #22c55e;" title="Green"></div>
<div class="color-option" data-color="#06b6d4" data-name="Cyan" style="background-color: #06b6d4;" title="Cyan"></div>
<div class="color-option selected" data-color="#3b82f6" data-name="Blue" style="background-color: #3b82f6;" title="Blue"></div>
<div class="color-option" data-color="#6366f1" data-name="Indigo" style="background-color: #6366f1;" title="Indigo"></div>
<div class="color-option" data-color="#8b5cf6" data-name="Purple" style="background-color: #8b5cf6;" title="Purple"></div>
<div class="color-option" data-color="#ec4899" data-name="Pink" style="background-color: #ec4899;" title="Pink"></div>
<div class="color-option" data-color="#64748b" data-name="Slate" style="background-color: #64748b;" title="Slate"></div>
</div>
</div>
</div>
</div>
<div class="form-group">
<label class="checkbox-label">
<input type="checkbox" id="event-all-day" />
<span>All Day Event</span>
</label>
</div>
<div class="form-actions">
<button type="button" class="btn btn-delete" id="delete-event-btn" onclick="deleteEvent()" style="display: none;">Delete</button>
<div class="form-actions-right">
<button type="button" class="btn btn-secondary" onclick="closeEventModal()">Cancel</button>
<button type="submit" class="btn btn-primary">Save</button>
</div>
</div>
</form>
</div>
</div>
</div>

<!-- Todo Modal -->
<div id="todo-modal" class="event-modal" style="display: none;">
<div class="event-modal-content">
<div class="event-modal-header">
<h2 id="todo-modal-title">New Todo</h2>
<button class="modal-close" onclick="closeTodoModal()">&times;</button>
</div>
<div class="event-modal-body">
<form id="todo-form">
<input type="hidden" id="todo-id" />
<div class="form-group">
<label for="todo-title">Title *</label>
<input type="text" id="todo-title" required placeholder="Todo title" />
</div>
<div class="form-group">
<label for="todo-description">Description</label>
<textarea id="todo-description" rows="3" placeholder="Todo description"></textarea>
</div>
<div class="form-row">
<div class="form-group">
<label for="todo-due-date">Due Date *</label>
<input type="date" id="todo-due-date" required />
</div>
<div class="form-group">
<label for="todo-duration">Duration (minutes)</label>
<input type="number" id="todo-duration" value="30" min="15" step="15" placeholder="30" />
</div>
</div>
<div class="form-row">
<div class="form-group">
<label for="todo-category">Category</label>
<input type="text" id="todo-category" placeholder="MEETING, WORK, etc." />
</div>
<div class="form-group">
<label for="todo-color">Color</label>
<input type="color" id="todo-color" value="#3b82f6" style="display: none;" />
<div class="color-dropdown">
<div class="color-dropdown-trigger" id="todo-color-dropdown-trigger">
<div class="color-preview" id="todo-color-preview" style="background-color: #3b82f6;"></div>
<span id="todo-color-name">Blue</span>
<span class="color-dropdown-arrow">▼</span>
</div>
<div class="color-picker-grid" id="todo-color-picker-grid">
<div class="color-option" data-color="#ef4444" data-name="Red" style="background-color: #ef4444;" title="Red"></div>
<div class="color-option" data-color="#f59e0b" data-name="Orange" style="background-color: #f59e0b;" title="Orange"></div>
<div class="color-option" data-color="#eab308" data-name="Yellow" style="background-color: #eab308;" title="Yellow"></div>
<div class="color-option" data-color="#22c55e" data-name="Green" style="background-color: #22c55e;" title="Green"></div>
<div class="color-option" data-color="#06b6d4" data-name="Cyan" style="background-color: #06b6d4;" title="Cyan"></div>
<div class="color-option selected" data-color="#3b82f6" data-name="Blue" style="background-color: #3b82f6;" title="Blue"></div>
<div class="color-option" data-color="#6366f1" data-name="Indigo" style="background-color: #6366f1;" title="Indigo"></div>
<div class="color-option" data-color="#8b5cf6" data-name="Purple" style="background-color: #8b5cf6;" title="Purple"></div>
<div class="color-option" data-color="#ec4899" data-name="Pink" style="background-color: #ec4899;" title="Pink"></div>
<div class="color-option" data-color="#64748b" data-name="Slate" style="background-color: #64748b;" title="Slate"></div>
</div>
</div>
</div>
</div>
<div class="form-group">
<label for="todo-priority">Priority</label>
<select id="todo-priority" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px; background: #1a1a1a; color: #fff;">
<option value="1">Low</option>
<option value="2">Medium</option>
<option value="3" selected>Normal</option>
<option value="4">High</option>
<option value="5">Urgent</option>
</select>
</div>
<div class="form-actions">
<button type="button" class="btn btn-delete" id="delete-todo-btn" onclick="deleteTodo()" style="display: none;">Delete</button>
<div class="form-actions-right">
<button type="button" class="btn btn-secondary" onclick="closeTodoModal()">Cancel</button>
<button type="submit" class="btn btn-primary">Save</button>
</div>
</div>
</form>
</div>
</div>
</div>

</main>
<!-- FullCalendar JS -->
<script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.8/index.global.min.js"></script>
<!-- Configuration and Supabase client -->
<script src="config.js"></script>
<script src="supabase-client.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
	const el = document.getElementById('calendar');
	if (!el) return;

	// Replace mini FullCalendar with a lightweight custom mini calendar (from example.html)
	const miniHost = document.querySelector('section.mini-calendar');
	if (miniHost) {
		// Clear all existing content first
		miniHost.innerHTML = '';
		// Add our custom mini calendar
		miniHost.innerHTML = '<div id="mini-calendar" aria-label="Mini month calendar"><div class="mini-grid" id="mini-calendar-grid"></div></div>';
		const grid = document.getElementById('mini-calendar-grid');
		if (grid) {
			const dayNames = ['SUN','MON','TUE','WED','THU','FRI','SAT'];
			const today = new Date();
			let currentMonth = today.getMonth();
			let currentYear = today.getFullYear();

			const dateSection = document.querySelector('section.date');
			const monthEl = dateSection?.querySelector('.div-3 .text-wrapper');
			const yearEl = dateSection?.querySelector('.div-3 .text-wrapper-2');
			const prevBtn = dateSection?.querySelector('button[aria-label="Previous month"]');
			const nextBtn = dateSection?.querySelector('button[aria-label="Next month"]');

			function updateHeader(month, year) {
				if (monthEl) monthEl.textContent = new Date(year, month).toLocaleString(undefined, { month: 'long' });
				if (yearEl) yearEl.textContent = String(year);
			}

			function fmtLocalYMD(d) {
				const y = d.getFullYear();
				const m = String(d.getMonth() + 1).padStart(2, '0');
				const day = String(d.getDate()).padStart(2, '0');
				return `${y}-${m}-${day}`;
			}

			async function renderMiniCalendar(month, year) {
				grid.innerHTML = '';
				updateHeader(month, year);

				// Day names header
				dayNames.forEach(d => {
					const div = document.createElement('div');
					div.textContent = d;
					div.className = 'mini-day-name';
					grid.appendChild(div);
				});

				// Build a 6x7 grid including prev/next month days
				const firstOfMonth = new Date(year, month, 1);
				const startDay = firstOfMonth.getDay();
				const daysInMonth = new Date(year, month + 1, 0).getDate();
				const daysInPrevMonth = new Date(year, month, 0).getDate();
				const totalCells = 42; // 6 weeks

			// Fetch events to render dots (color field used)
			let events = [];
			try {
				events = await window.fetchSupabaseEvents();
			} catch (e) {
				console.error('Failed to fetch events for mini calendar:', e);
			}				// Bucket events by YYYY-MM-DD
				const dotsByDay = new Map();
				for (const ev of events) {
					const d = new Date(ev.start);
					const key = fmtLocalYMD(d);
					const list = dotsByDay.get(key) || [];
					list.push(ev.color || '#3b82f6');
					dotsByDay.set(key, list);
				}

				for (let cell = 0; cell < totalCells; cell++) {
					const dayIndex = cell - startDay + 1;
					let cellDate, inCurrent;
					if (dayIndex < 1) {
						// previous month
						const d = daysInPrevMonth + dayIndex;
						cellDate = new Date(year, month - 1, d);
						inCurrent = false;
					} else if (dayIndex > daysInMonth) {
						// next month
						const d = dayIndex - daysInMonth;
						cellDate = new Date(year, month + 1, d);
						inCurrent = false;
					} else {
						// current month
						cellDate = new Date(year, month, dayIndex);
						inCurrent = true;
					}

				const wrap = document.createElement('div');
				wrap.className = 'mini-cell';

				const btn = document.createElement('button');
				btn.type = 'button';
				btn.textContent = String(cellDate.getDate());
				btn.className = 'mini-day';
				if (!inCurrent) btn.classList.add('mini-dim');
				if (
					cellDate.getDate() === today.getDate() &&
					cellDate.getMonth() === today.getMonth() &&
					cellDate.getFullYear() === today.getFullYear()
				) {
					btn.classList.add('today');
					btn.setAttribute('aria-current', 'date');
				}
				
				// Add click handler to navigate main calendar
				btn.addEventListener('click', () => {
					if (window.calendar) {
						window.calendar.gotoDate(cellDate);
					}
				});
				
				wrap.appendChild(btn);					// dots
					const dots = document.createElement('div');
					dots.className = 'mini-dots';
					const key = fmtLocalYMD(cellDate);
					(dotsByDay.get(key) || []).slice(0,4).forEach(color => {
						const dot = document.createElement('span');
						dot.className = 'mini-dot';
						dot.style.background = color;
						dots.appendChild(dot);
					});
					if (!inCurrent) dots.classList.add('mini-dim');
					wrap.appendChild(dots);

					grid.appendChild(wrap);
				}
			}

			// Wire chevrons
			prevBtn?.addEventListener('click', (e) => { e.preventDefault(); currentMonth--; if (currentMonth < 0) { currentMonth = 11; currentYear--; } renderMiniCalendar(currentMonth, currentYear); });
			nextBtn?.addEventListener('click', (e) => { e.preventDefault(); currentMonth++; if (currentMonth > 11) { currentMonth = 0; currentYear++; } renderMiniCalendar(currentMonth, currentYear); });

			// Initial render
			renderMiniCalendar(currentMonth, currentYear);
			
			// Make refresh function globally accessible
			window.refreshMiniCalendar = function() {
				renderMiniCalendar(currentMonth, currentYear);
			};
		}
	}

	const calendar = new FullCalendar.Calendar(el, {
		initialView: 'timeGridWeek',
		headerToolbar: false,
		nowIndicator: true,
		// show the full 24 hours
		slotMinTime: '00:00:00',
		slotMaxTime: '24:00:00',
		scrollTime: '08:00:00',
		contentHeight: 'auto',
		allDaySlot: false,
		selectable: true,
		editable: true,
		droppable: true, // Enable dropping external elements
		height: 'auto',
		events: window.fetchSupabaseEvents,
		// Click on empty time slot to create new event
		select: function(info) {
			openEventModal(null, info.start, info.end, info.allDay);
			calendar.unselect(); // Clear the selection
		},
		// Click on existing event to edit
		eventClick: function(info) {
			info.jsEvent.preventDefault(); // Prevent browser navigation
			const event = info.event;
		openEventModal(event);
	},
	// Enable dropping todos from sidebar
	droppable: true,
	eventReceive: async function(info) {
		// Prevent the default event creation and handle manually
		info.event.remove();
		
		// Get the todo data from the dragged element
		const todoData = JSON.parse(info.draggedEl.dataset.todoData);
		
		// Create event data for saving
		const eventData = {
			title: todoData.title,
			start: info.event.start.toISOString(),
			end: info.event.end ? info.event.end.toISOString() : new Date(info.event.start.getTime() + (todoData.duration * 60000)).toISOString(),
			color: todoData.color,
			allDay: info.event.allDay || false,
			description: `Created from todo: ${todoData.title}`
		};
		
		try {
			// Save the event to the database
			const savedEvent = await window.saveEventToSupabase(eventData);
			console.log('Todo converted to event and saved:', savedEvent);
			
			// Refresh calendar to show the saved event
			calendar.refetchEvents();
			
			// Reload todos to update the sidebar
			loadTodos();
			
			// Refresh mini calendar
			if (window.refreshMiniCalendar) window.refreshMiniCalendar();
		} catch (error) {
			console.error('Failed to save dropped todo as event:', error);
			alert('Failed to create event. Please try again.');
		}
	},
	drop: function(info) {
		// This callback is kept for compatibility but main handling is in eventReceive
		console.log('Drop event triggered:', info);
	},
	// Debug hooks to confirm FullCalendar is receiving and rendering events
		eventsSet: function(events) {
			console.log('FullCalendar eventsSet ->', events.length, 'events');
		},
		eventDidMount: function(info) {
			console.log('FullCalendar eventDidMount:', info.event.id, info.event.title, info.event.start, info.event.end);
			// mark the DOM element so we can visually locate it in week view
			try { if (info.el && info.el.classList) info.el.classList.add('fc-debug-mounted'); } catch (e) {}
		}
	});
	calendar.render();
	
	// Make calendar globally accessible for sidebar toggle
	window.calendar = calendar;

	// quick diagnostic: try to fetch events from Supabase and log success/failure
	// so it's obvious in the browser console if the connection can't be established
	window.fetchSupabaseEvents().then(data => {
		console.log('Events loaded:', data.length, 'events');
	}).catch(err => {
		console.error('Failed to load events:', err);
	});
	// Force FullCalendar to recalculate sizes so the CSS row heights are applied
	setTimeout(() => calendar.updateSize(), 50);

	// Prev / Next / Today wiring (if those buttons exist elsewhere on the page)
	const prev = document.querySelector('button[aria-label="Previous week"]');
	const next = document.querySelector('button[aria-label="Next week"]');
	const today = Array.from(document.querySelectorAll('button.button')).find(b => b.textContent.trim() === 'Today');
	if (prev) prev.addEventListener('click', () => calendar.prev());
	if (next) next.addEventListener('click', () => calendar.next());
	if (today) today.addEventListener('click', () => calendar.today());

	// Wire the custom view tabs (Day / Week / Month / Year) to change the FullCalendar view
	const viewButtons = Array.from(document.querySelectorAll('nav[role="tablist"] button.button'));
	const viewMap = {
		'Day': 'timeGridDay',
		'Week': 'timeGridWeek',
		'Month': 'dayGridMonth',
		'Year': 'dayGridMonth' // FullCalendar doesn't include a native year view in the core; fallback to month
	};

	function updateActiveViewButton(viewType) {
		// determine the label that corresponds to the current view
		const inv = { 'timeGridDay':'Day', 'timeGridWeek':'Week', 'dayGridMonth':'Month' };
		const label = inv[viewType] || 'Week';
		viewButtons.forEach(b => {
			b.setAttribute('aria-selected', 'false');
			const inner = b.querySelector('div');
			if (inner) {
				inner.classList.remove('button-master-3');
				inner.classList.add('button-master-2');
			}
			if (b.textContent.trim() === label) {
				b.setAttribute('aria-selected', 'true');
				if (inner) {
					inner.classList.remove('button-master-2');
					inner.classList.add('button-master-3');
				}
			}
		});
	}

	viewButtons.forEach(btn => {
		btn.addEventListener('click', (e) => {
			e.preventDefault();
			const text = btn.textContent.trim();
			const view = viewMap[text] || 'timeGridWeek';
			calendar.changeView(view);
			updateActiveViewButton(view);
			// ensure FullCalendar re-evaluates events/layout when switching views
			try { calendar.refetchEvents(); } catch (err) { /* ignore */ }
			try { calendar.render(); calendar.updateSize(); } catch (err) { /* ignore */ }
		});
	});

	// Keep the active tab in sync when view changes programmatically
	calendar.on('datesSet', function() {
		updateActiveViewButton(calendar.view.type);
		// log current view and visible range for debugging
		try {
			console.log('FullCalendar current view:', calendar.view.type, 'range:', calendar.view.activeStart, '->', calendar.view.activeEnd);
		} catch (e) {}
	});

	// Add a mirrored right-hand hour axis for visual symmetry
	function ensureRightAxis() {
		// the left axis uses .fc-timegrid-axis
		const leftAxis = el.querySelector('.fc-timegrid-axis');
		if (!leftAxis) return;
		let rightAxis = el.querySelector('.my-right-axis');
		if (!rightAxis) {
			rightAxis = document.createElement('div');
			rightAxis.className = 'my-right-axis';
			rightAxis.setAttribute('aria-hidden', 'true');
			rightAxis.style.position = 'absolute';
			rightAxis.style.top = '0';
			rightAxis.style.right = '0';
			rightAxis.style.width = '32px';
			rightAxis.style.pointerEvents = 'none';
			rightAxis.style.textAlign = 'center';
			el.appendChild(rightAxis);
		}
		// copy the hour labels from left axis
		rightAxis.innerHTML = leftAxis.innerHTML;
		// sync scroll between the calendar scrollable area and our right axis
		const scrollable = el.querySelector('.fc-scroller');
		if (scrollable) {
			scrollable.addEventListener('scroll', () => {
				rightAxis.scrollTop = scrollable.scrollTop;
			});
		}
	}

	// ensure once rendered and whenever dates change
	setTimeout(ensureRightAxis, 100);
	calendar.on('datesSet', ensureRightAxis);

	// Make the calendar's first row of dates sticky directly under our header
	function ensureStickyDayHeader() {
		const header = document.querySelector('.calendar-base > header.div-5');
		if (!header) return;
		// offset should be exactly the rendered header height (includes padding)
		const headerHeight = header.getBoundingClientRect().height || 0;
		// set CSS variable on calendar mount
		el.style.setProperty('--header-height', headerHeight + 'px');
		// common FullCalendar header selectors to make sticky
		const selectors = [
			'.fc-col-header',
			'.fc-col-header-cell',
			'.fc-col-header-row',
			'.fc-daygrid-head',
			'.fc-scrollgrid-section-header'
		];
		selectors.forEach(sel => {
			const nodes = el.querySelectorAll(sel);
			nodes.forEach(n => {
				n.style.position = 'sticky';
				n.style.top = 'var(--header-height)';
				n.style.zIndex = '55';
				n.style.background = 'inherit';
			});
		});
	}

	// run after render and when dates change or window resizes
	setTimeout(ensureStickyDayHeader, 150);
	calendar.on('datesSet', ensureStickyDayHeader);
	window.addEventListener('resize', ensureStickyDayHeader);

	// Format the first row header cells: weekday (3-letter) on top, big date below
	function formatHeaderCells() {
		// possible selectors for different FullCalendar views
		const headerCells = el.querySelectorAll('.fc-col-header-cell, .fc-daygrid-day-top, .fc-col-header');
		if (!headerCells || headerCells.length === 0) return;
		// determine the parent row to find the first cell to skip
		const parent = headerCells[0].parentElement;
		headerCells.forEach((cell, idx) => {
			// if this cell is the first in the row, skip (leave untouched)
			if (parent) {
				const children = Array.from(parent.children).filter(n => n.nodeType === 1);
				if (children.indexOf(cell) === 0) return;
			}
			if (cell.dataset.fcFormatted) return; // already formatted
			// Try to get a real date from dataset or a <time> element
			let dateStr = cell.dataset && (cell.dataset.date || cell.dataset.fcDate) ? (cell.dataset.date || cell.dataset.fcDate) : null;
			if (!dateStr) {
				const timeEl = cell.querySelector('time');
				if (timeEl && timeEl.dateTime) dateStr = timeEl.dateTime;
				else if (timeEl && timeEl.getAttribute('datetime')) dateStr = timeEl.getAttribute('datetime');
			}
			let weekday = '';
			let daynum = '';
			if (dateStr) {
				// parse ISO date (YYYY-MM-DD or full datetime)
				const d = new Date(dateStr);
				if (!Number.isNaN(d.getTime())) {
					const opts = { weekday: 'short' };
					weekday = d.toLocaleDateString(undefined, opts).toUpperCase().slice(0,3);
					daynum = String(d.getDate());
				}
			}
			// fallback to previous heuristics if parsing failed
			if (!weekday || !daynum) {
				const text = cell.innerText.trim();
				if (!text) return;
				const parts = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
				if (parts.length >= 2) {
					weekday = parts[0];
					daynum = parts[1];
				} else {
					const tokens = text.split(/\s+/);
					daynum = tokens[tokens.length - 1];
					weekday = tokens.slice(0, tokens.length - 1).join(' ');
				}
				weekday = weekday.toUpperCase().slice(0,3);
				const m = daynum.match(/(\d{1,2})/);
				if (m) daynum = m[1];
			}
			// build the new content, left-aligned
			cell.innerHTML = `<div class="fc-custom-day-name">${weekday}</div><div class="fc-custom-day-num">${daynum}</div>`;
			cell.dataset.fcFormatted = '1';
		});
	}

	setTimeout(formatHeaderCells, 200);
	calendar.on('datesSet', formatHeaderCells);
});

// Load and render todos in the left menu (moved outside DOMContentLoaded to be globally accessible)
async function loadTodos() {
	try {
		console.log('Loading todos from Supabase...');
		const todos = await window.fetchSupabaseTodos();
		console.log('Todos loaded successfully:', todos);
		console.log('Number of todos:', todos ? todos.length : 0);
		renderTodos(todos || []);
	} catch (error) {
		console.error('Failed to load todos:', error);
		// Try to render empty todos to at least show the structure
		renderTodos([]);
	}
}

function renderTodos(todos) {
	const daysWrapper = document.querySelector('.days-wrapper');
	if (!daysWrapper) {
		console.warn('days-wrapper element not found');
		return;
	}

	console.log('renderTodos called with:', todos);
	console.log('daysWrapper found:', daysWrapper);

	// Handle undefined or null todos
	if (!todos || !Array.isArray(todos)) {
		console.error('Invalid todos data:', todos);
		todos = [];
	}

	console.log('Rendering', todos.length, 'todos');

	// Clear existing content
	daysWrapper.innerHTML = '<div class="days"></div>';
	const daysContainer = daysWrapper.querySelector('.days');

	// Calculate progress statistics
	const today = new Date();
	today.setHours(0, 0, 0, 0);
	
	const startOfWeek = new Date(today);
	startOfWeek.setDate(today.getDate() - today.getDay()); // Sunday
	
	const endOfWeek = new Date(startOfWeek);
	endOfWeek.setDate(startOfWeek.getDate() + 6); // Saturday
	
	// Filter todos for today
	const todayTodos = todos.filter(todo => {
		if (!todo.dueDate) return false;
		const dueDate = new Date(todo.dueDate);
		dueDate.setHours(0, 0, 0, 0);
		return dueDate.getTime() === today.getTime();
	});
	
	// Filter todos for this week
	const weekTodos = todos.filter(todo => {
		if (!todo.dueDate) return false;
		const dueDate = new Date(todo.dueDate);
		dueDate.setHours(0, 0, 0, 0);
		return dueDate >= startOfWeek && dueDate <= endOfWeek;
	});
	
	// Calculate completion percentages
	const todayCompleted = todayTodos.filter(t => t.completed).length;
	const todayTotal = todayTodos.length;
	const weekCompleted = weekTodos.filter(t => t.completed).length;
	const weekTotal = weekTodos.length;
	
	const todayPercent = todayTotal > 0 ? Math.round((todayCompleted / todayTotal) * 100) : 100;
	const weekPercent = weekTotal > 0 ? Math.round((weekCompleted / weekTotal) * 100) : 100;
	
	// Add progress charts at the top
	const progressSection = document.createElement('div');
	progressSection.className = 'todo-progress-section';
	progressSection.innerHTML = `
		<div class="progress-charts">
			<div class="progress-chart">
				<svg width="70" height="70" viewBox="0 0 70 70">
					<circle cx="35" cy="35" r="28" fill="none" stroke="rgba(255, 255, 255, 0.1)" stroke-width="6"/>
					<circle cx="35" cy="35" r="28" fill="none" stroke="#3b82f6" stroke-width="6" 
						stroke-dasharray="${2 * Math.PI * 28}" 
						stroke-dashoffset="${2 * Math.PI * 28 * (1 - todayPercent / 100)}" 
						transform="rotate(-90 35 35)" stroke-linecap="round"/>
					<text x="35" y="39" text-anchor="middle" font-size="16" font-weight="700" fill="rgba(255, 255, 255, 0.95)">${todayPercent}%</text>
				</svg>
				<div class="progress-label">
					<div class="progress-title">Today</div>
					<div class="progress-stats">${todayCompleted}/${todayTotal} done</div>
				</div>
			</div>
			<div class="progress-chart">
				<svg width="70" height="70" viewBox="0 0 70 70">
					<circle cx="35" cy="35" r="28" fill="none" stroke="rgba(255, 255, 255, 0.1)" stroke-width="6"/>
					<circle cx="35" cy="35" r="28" fill="none" stroke="#10b981" stroke-width="6" 
						stroke-dasharray="${2 * Math.PI * 28}" 
						stroke-dashoffset="${2 * Math.PI * 28 * (1 - weekPercent / 100)}" 
						transform="rotate(-90 35 35)" stroke-linecap="round"/>
					<text x="35" y="39" text-anchor="middle" font-size="16" font-weight="700" fill="rgba(255, 255, 255, 0.95)">${weekPercent}%</text>
				</svg>
				<div class="progress-label">
					<div class="progress-title">This Week</div>
					<div class="progress-stats">${weekCompleted}/${weekTotal} done</div>
				</div>
			</div>
		</div>
	`;
	daysContainer.appendChild(progressSection);
	console.log('Progress section added to daysContainer');

	// Group todos by due date - only include dates that have todos
	const todosByDate = {};
	todos.forEach(todo => {
		const dateKey = todo.dueDate;
		if (dateKey) { // Only add if dueDate exists
			if (!todosByDate[dateKey]) {
				todosByDate[dateKey] = [];
			}
			todosByDate[dateKey].push(todo);
		}
	});

	// Always show TODAY section
	const todayKey = today.toISOString().split('T')[0];
	if (!todosByDate[todayKey]) {
		todosByDate[todayKey] = [];
	}

	// Sort dates
	const sortedDates = Object.keys(todosByDate).sort();

	// Helper function to format date titles
	function getDateTitle(dateStr) {
		const date = new Date(dateStr);
		const today = new Date();
		today.setHours(0, 0, 0, 0);
		const tomorrow = new Date(today);
		tomorrow.setDate(today.getDate() + 1);
		
		const compareDate = new Date(date);
		compareDate.setHours(0, 0, 0, 0);

		if (compareDate.getTime() === today.getTime()) {
			return 'TODAY';
		} else if (compareDate.getTime() === tomorrow.getTime()) {
			return 'TOMORROW';
		} else {
			return date.toLocaleDateString('en-US', { weekday: 'long' }).toUpperCase();
		}
	}

	function formatDateString(dateStr) {
		const date = new Date(dateStr);
		return date.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' });
	}

	// Render todos grouped by date
	sortedDates.forEach(dateKey => {
		const todosForDate = todosByDate[dateKey];
		const dateTitle = getDateTitle(dateKey);
		const formattedDate = formatDateString(dateKey);
		const dateObj = new Date(dateKey + 'T00:00:00');
		const isToday = dateObj.getTime() === today.getTime();

		// Skip rendering if not today and no todos
		if (!isToday && todosForDate.length === 0) {
			return; // Don't show empty date sections for non-today dates
		}

		// Add date header
		const dateHeader = document.createElement('header');
		dateHeader.className = isToday ? 'today-header' : 'date-header';
		dateHeader.innerHTML = `
			<h2 class="text-wrapper-${dateTitle === 'TODAY' ? '3' : '4'}">${isToday ? 'Today' : dateTitle}</h2>
			<time class="${dateTitle === 'TODAY' ? 'element' : 'text-wrapper-5'}" datetime="${dateKey}">${formattedDate}</time>
		`;
		daysContainer.appendChild(dateHeader);

		// Show "No todos" message if today has no todos
		if (isToday && todosForDate.length === 0) {
			const emptyState = document.createElement('div');
			emptyState.className = 'no-todos-message';
			emptyState.innerHTML = '<p>Great. You have done everything.</p>';
			daysContainer.appendChild(emptyState);
			return; // Skip rendering todos since there are none
		}

		// Add todos for this date
		todosForDate.forEach(todo => {
			const todoArticle = document.createElement('article');
			todoArticle.className = 'event';
			todoArticle.draggable = true;
			todoArticle.dataset.todoId = todo.id;
			todoArticle.dataset.todoData = JSON.stringify({
				id: todo.id,
				title: todo.title,
				duration: todo.duration || 30,
				color: todo.color,
				dueDate: todo.dueDate
			});

			// Determine ellipse color class based on category
			const ellipseClass = todo.color === '#ef4444' ? 'ellipse-3' : 
			                    todo.color === '#f59e0b' ? 'ellipse-4' : 
			                    todo.color === '#8b5cf6' ? 'ellipse-5' : 'ellipse-3';

			todoArticle.innerHTML = `
				<div class="meta">
					<div class="${ellipseClass}" aria-hidden="true" style="background-color: ${todo.color}"></div>
					<div class="div-3">
						<span class="text-wrapper-7">${todo.category ? todo.category.toUpperCase() : 'TASK'}</span>
						<span class="text-wrapper-8">•</span>
						<span class="text-wrapper-7">${todo.duration || 30}min</span>
					</div>
				</div>
				<div class="div-wrapper"><h3 class="text-wrapper-9">${todo.title}</h3></div>
				${todo.description ? `<div class="div-wrapper"><span class="text-wrapper-10">${todo.description}</span></div>` : ''}
			`;

		// Add drag event listeners
		todoArticle.addEventListener('dragstart', (e) => {
			const todoData = {
				title: todo.title,
				duration: todo.duration || 30,
				color: todo.color,
				id: todo.id,
				dueDate: todo.dueDate
			};
			e.dataTransfer.setData('application/json', JSON.stringify(todoData));
			e.dataTransfer.effectAllowed = 'copy';
			
			// Create custom drag image
			const dragPreview = document.createElement('div');
			dragPreview.style.cssText = `
				position: absolute;
				top: -1000px;
				left: -1000px;
				width: 200px;
				padding: 8px 12px;
				background: ${todo.color};
				color: white;
				border-radius: 4px;
				font-family: inherit;
				font-size: 14px;
				font-weight: 500;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
				pointer-events: none;
				z-index: 10000;
			`;
			dragPreview.innerHTML = `
				<div style="margin-bottom: 4px; font-size: 12px; opacity: 0.9;">
					${todo.category ? todo.category.toUpperCase() : 'TASK'} • ${todo.duration || 30}min
				</div>
				<div style="font-size: 14px; font-weight: 600;">
					${todo.title}
				</div>
			`;
			document.body.appendChild(dragPreview);
			e.dataTransfer.setDragImage(dragPreview, 100, 30);
			
			// Remove the preview element after a short delay
			setTimeout(() => dragPreview.remove(), 0);
			
			todoArticle.style.opacity = '0.5';
		});

		todoArticle.addEventListener('dragend', (e) => {
			todoArticle.style.opacity = '1';
		});			daysContainer.appendChild(todoArticle);
		});
	});

	// Initialize external dragging after todos are rendered
	setTimeout(() => initExternalDragging(), 100);
}

// Initialize FullCalendar external dragging
function initExternalDragging() {
	const todoItems = document.querySelectorAll('article.event[draggable="true"]');
	todoItems.forEach(item => {
		new FullCalendar.Draggable(item, {
			eventData: function(eventEl) {
				const todoData = JSON.parse(eventEl.dataset.todoData);
				return {
					title: todoData.title,
					duration: { minutes: todoData.duration || 30 },
					backgroundColor: todoData.color,
					borderColor: todoData.color,
					textColor: '#ffffff',
					extendedProps: {
						todoId: todoData.id,
						duration: todoData.duration || 30
					}
				};
			}
		});
	});
}

// Sidebar Toggle Functionality
function toggleSidebar() {
	const fantastical = document.querySelector('.fantastical');
	const toggleButton = document.querySelector('.sidebar-toggle');
	const toggleIcon = document.querySelector('.sidebar-toggle-icon');
	
	if (fantastical) {
		const isHidden = fantastical.classList.contains('sidebar-hidden');
		
		if (isHidden) {
			// Show sidebar
			fantastical.classList.remove('sidebar-hidden');
			toggleIcon.textContent = '×';  // Show X when sidebar is open
		} else {
			// Hide sidebar
			fantastical.classList.add('sidebar-hidden');
			toggleIcon.textContent = '☰';  // Show hamburger when sidebar is closed
		}
		
		// Force FullCalendar to recalculate dimensions with proper timing
		if (window.calendar) {
			// Immediate update to start the process
			requestAnimationFrame(() => {
				window.calendar.updateSize();
				
				// Additional updates during and after transition
				setTimeout(() => {
					window.calendar.updateSize();
				}, 150); // Mid-transition update
				
				setTimeout(() => {
					window.calendar.updateSize();
					// Force a final render to ensure everything is properly sized
					window.calendar.render();
				}, 350); // Final update after transition completes
			});
		}
	}
}

// Toggle right menu function
function toggleRightMenu() {
	const fantastical = document.querySelector('.fantastical');
	const toggleButton = document.querySelector('.right-menu-toggle');
	const toggleIcon = document.querySelector('.right-menu-toggle-icon');
	
	if (fantastical && toggleButton && toggleIcon) {
		if (fantastical.classList.contains('right-menu-hidden')) {
			// Show right menu
			fantastical.classList.remove('right-menu-hidden');
			toggleIcon.textContent = '✕';  // Show X when right menu is open
		} else {
			// Hide right menu
			fantastical.classList.add('right-menu-hidden');
			toggleIcon.textContent = '⚙️';  // Show gear when right menu is closed
		}
		
		// Force FullCalendar to recalculate dimensions with proper timing
		if (window.calendar) {
			// Immediate update to start the process
			requestAnimationFrame(() => {
				window.calendar.updateSize();
				
				// Additional updates during and after transition
				setTimeout(() => {
					window.calendar.updateSize();
				}, 150); // Mid-transition update
				
				setTimeout(() => {
					window.calendar.updateSize();
					// Force a final render to ensure everything is properly sized
					window.calendar.render();
				}, 350); // Final update after transition completes
			});
		}
	}
}

// Chat functionality with AI
async function sendMessage() {
	const input = document.getElementById('chat-input');
	const messagesContainer = document.getElementById('chat-messages');
	
	if (!input || !messagesContainer || !input.value.trim()) return;
	
	const userMessage = input.value.trim();
	input.value = '';
	
	// Add user message
	addChatMessage(userMessage, 'user');
	
	// Show animated thinking dots
	const assistantMessageDiv = addChatMessage('...', 'assistant thinking', false);
	
	try {
		// Send to AI assistant
		const response = await callAIAssistant(userMessage, assistantMessageDiv);
		
		// Execute any actions the AI determined
		if (response.actions && response.actions.length > 0) {
			// Keep showing dots while executing actions
			assistantMessageDiv.textContent = '...';
			assistantMessageDiv.classList.add('thinking');
			
			let hasError = false;
			for (const action of response.actions) {
				const result = await executeAIAction(action);
				if (!result.success) {
					hasError = true;
					assistantMessageDiv.classList.remove('thinking');
					assistantMessageDiv.textContent = `Error: ${result.error}`;
					break;
				}
			}
			
			// If no error, show the clean message
			if (!hasError) {
				assistantMessageDiv.classList.remove('thinking');
				assistantMessageDiv.textContent = response.message;
			}
		}
	} catch (error) {
		console.error('AI Error:', error);
		assistantMessageDiv.textContent = 'Sorry, I encountered an error. Please try again.';
	}
}

function addChatMessage(text, role = 'user', isTyping = false) {
	const messagesContainer = document.getElementById('chat-messages');
	const messageDiv = document.createElement('div');
	messageDiv.className = `chat-message chat-message-${role}${isTyping ? ' typing' : ''}`;
	messageDiv.textContent = text;
	messagesContainer.appendChild(messageDiv);
	messagesContainer.scrollTop = messagesContainer.scrollHeight;
	return messageDiv;
}

// Timezone conversion utilities
function convertLocalToUTC(localDateTimeString) {
	// Takes a datetime string like "2025-12-11T16:00:00" in user's local timezone
	// Returns ISO string in UTC for database storage
	const localDate = new Date(localDateTimeString);
	return localDate.toISOString();
}

function convertUTCToLocal(utcDateTimeString) {
	// Takes UTC datetime string from database
	// Returns formatted local datetime for FullCalendar
	return utcDateTimeString; // FullCalendar handles this automatically
}

function generateRecurringEvents(baseEvent, recurrence) {
	const events = [];
	const seriesId = generateUUID();
	const startDate = new Date(baseEvent.start);
	const endDate = new Date(baseEvent.end);
	const duration = endDate - startDate; // milliseconds
	
	const { frequency, daysOfWeek, count = 10, interval = 1 } = recurrence;
	
	if (frequency === 'DAILY') {
		for (let i = 0; i < count; i++) {
			const eventStart = new Date(startDate);
			eventStart.setDate(startDate.getDate() + (i * interval));
			const eventEnd = new Date(eventStart.getTime() + duration);
			
			// Create local datetime string then convert to UTC
			const localStartStr = eventStart.getFullYear() + '-' + 
				String(eventStart.getMonth() + 1).padStart(2, '0') + '-' + 
				String(eventStart.getDate()).padStart(2, '0') + 'T' +
				String(eventStart.getHours()).padStart(2, '0') + ':' +
				String(eventStart.getMinutes()).padStart(2, '0') + ':00';
			const localEndStr = eventEnd.getFullYear() + '-' + 
				String(eventEnd.getMonth() + 1).padStart(2, '0') + '-' + 
				String(eventEnd.getDate()).padStart(2, '0') + 'T' +
				String(eventEnd.getHours()).padStart(2, '0') + ':' +
				String(eventEnd.getMinutes()).padStart(2, '0') + ':00';
			
			events.push({
				...baseEvent,
				start: convertLocalToUTC(localStartStr),
				end: convertLocalToUTC(localEndStr),
				seriesId,
				isRecurring: true
			});
		}
	} else if (frequency === 'WEEKLY') {
		const dayMap = { SU: 0, MO: 1, TU: 2, WE: 3, TH: 4, FR: 5, SA: 6 };
		const targetDays = daysOfWeek.map(d => dayMap[d]);
		
		let currentDate = new Date(startDate);
		let created = 0;
		
		while (created < count) {
			const currentDay = currentDate.getDay();
			
			if (targetDays.includes(currentDay)) {
				const eventStart = new Date(currentDate);
				eventStart.setHours(startDate.getHours(), startDate.getMinutes(), 0, 0);
				const eventEnd = new Date(eventStart.getTime() + duration);
				
				// Create local datetime string then convert to UTC
				const localStartStr = eventStart.getFullYear() + '-' + 
					String(eventStart.getMonth() + 1).padStart(2, '0') + '-' + 
					String(eventStart.getDate()).padStart(2, '0') + 'T' +
					String(eventStart.getHours()).padStart(2, '0') + ':' +
					String(eventStart.getMinutes()).padStart(2, '0') + ':00';
				const localEndStr = eventEnd.getFullYear() + '-' + 
					String(eventEnd.getMonth() + 1).padStart(2, '0') + '-' + 
					String(eventEnd.getDate()).padStart(2, '0') + 'T' +
					String(eventEnd.getHours()).padStart(2, '0') + ':' +
					String(eventEnd.getMinutes()).padStart(2, '0') + ':00';
				
				events.push({
					...baseEvent,
					start: convertLocalToUTC(localStartStr),
					end: convertLocalToUTC(localEndStr),
					seriesId,
					isRecurring: true
				});
				created++;
			}
			
			currentDate.setDate(currentDate.getDate() + 1);
		}
	} else if (frequency === 'MONTHLY') {
		for (let i = 0; i < count; i++) {
			const eventStart = new Date(startDate);
			eventStart.setMonth(startDate.getMonth() + (i * interval));
			const eventEnd = new Date(eventStart.getTime() + duration);
			
			// Create local datetime string then convert to UTC
			const localStartStr = eventStart.getFullYear() + '-' + 
				String(eventStart.getMonth() + 1).padStart(2, '0') + '-' + 
				String(eventStart.getDate()).padStart(2, '0') + 'T' +
				String(eventStart.getHours()).padStart(2, '0') + ':' +
				String(eventStart.getMinutes()).padStart(2, '0') + ':00';
			const localEndStr = eventEnd.getFullYear() + '-' + 
				String(eventEnd.getMonth() + 1).padStart(2, '0') + '-' + 
				String(eventEnd.getDate()).padStart(2, '0') + 'T' +
				String(eventEnd.getHours()).padStart(2, '0') + ':' +
				String(eventEnd.getMinutes()).padStart(2, '0') + ':00';
			
			events.push({
				...baseEvent,
				start: convertLocalToUTC(localStartStr),
				end: convertLocalToUTC(localEndStr),
				seriesId,
				isRecurring: true
			});
		}
	}
	
	return events;
}

function generateUUID() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
		const r = Math.random() * 16 | 0;
		const v = c === 'x' ? r : (r & 0x3 | 0x8);
		return v.toString(16);
	});
}

async function callAIAssistant(userMessage, messageDiv) {
	if (!window.ENV.OPENAI_API_KEY) {
		messageDiv.textContent = 'OpenAI API key not configured. Please add OPENAI_API_KEY to .env.local';
		return { message: '', actions: [] };
	}
	
	// Get current user
	const user = await window.getCurrentUser();
	
	// Get context about current calendar state
	const currentDate = new Date().toISOString().split('T')[0];
	const calendarView = window.calendar ? window.calendar.view.type : 'timeGridWeek';
	
	const systemPrompt = `You are a helpful AI assistant for a calendar application. You help users manage their events and todos.

Current date: ${currentDate}
Calendar view: ${calendarView}
User ID: ${user?.id || 'not authenticated'}

You can help with:
1. Creating events (one-time or recurring)
2. Creating todos
3. Updating events
4. Deleting events or todos
5. Answering questions about their calendar
6. Providing counseling and productivity advice

IMPORTANT: When creating events or todos, respond ONLY with a JSON object containing:
1. A SHORT, natural confirmation message (e.g., "Added meeting tomorrow" or "Scheduled your weekly meetings")
2. The actions array with the database operations

DO NOT include JSON code in your visible message. The JSON structure is for the system only.

TIME PARSING RULES - CRITICAL:
- Parse times EXACTLY as user specifies in their LOCAL timezone
- "5pm" = 17:00:00, "6pm" = 18:00:00
- "5am" = 05:00:00, "6am" = 06:00:00
- "3:30pm" = 15:30:00
- "4pm" = 16:00:00, "noon" = 12:00:00
- Use 24-hour format WITHOUT timezone: YYYY-MM-DDTHH:MM:SS (system will handle timezone conversion)
- If user says "5pm to 6pm", start=17:00:00, end=18:00:00
- If user says "4pm to 6pm", start=16:00:00, end=18:00:00
- If no time specified, use 09:00:00 as default
- NEVER add timezone offset - use plain datetime

DATE PARSING RULES - CRITICAL:
- Current date is: ${currentDate}
- "tomorrow" = ${new Date(new Date(currentDate).getTime() + 86400000).toISOString().split('T')[0]}
- "today" = ${currentDate}
- "next Monday" = find next occurrence of Monday from current date
- Always use YYYY-MM-DD format

Response format:
{
  "message": "Added meeting tomorrow",
  "actions": [{
    "type": "create_event",
    "data": {
      "title": "Meeting",
      "start": "2025-12-11T17:00:00",
      "end": "2025-12-11T18:00:00",
      "color": "#3b82f6",
      "allDay": false
    }
  }]
}

For recurring events:
{
  "message": "Scheduled your weekly meetings",
  "actions": [{
    "type": "create_recurring_event",
    "data": {
      "title": "Weekly Meeting",
      "start": "2025-12-10T15:00:00",
      "end": "2025-12-10T18:00:00",
      "color": "#3b82f6",
      "allDay": false,
      "recurrence": {
        "frequency": "WEEKLY",
        "daysOfWeek": ["TU"],
        "count": 4
      }
    }
  }]
}

For todos:
{
  "message": "Added task to your list",
  "actions": [{
    "type": "create_todo",
    "data": {
      "title": "Task name",
      "description": "Optional description",
      "dueDate": "2025-12-11",
      "duration": 30,
      "category": "WORK",
      "priority": 3,
      "color": "#3b82f6"
    }
  }]
}

For counseling or general questions, respond naturally without actions:
{
  "message": "Here are some tips for productivity..."
}

Parse natural language dates accurately:
- "tomorrow" = ${new Date(new Date(currentDate).getTime() + 86400000).toISOString().split('T')[0]}
- "next week" = add 7 days
- Day names = next occurrence of that day

Be conversational and brief in your messages. The system will handle the database operations.`;

	try {
		const response = await fetch('https://api.openai.com/v1/chat/completions', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${window.ENV.OPENAI_API_KEY}`
			},
			body: JSON.stringify({
				model: 'gpt-4o-mini',
				messages: [
					{ role: 'system', content: systemPrompt },
					{ role: 'user', content: userMessage }
				],
				temperature: 0.7,
				stream: true
			})
		});
		
		if (!response.ok) {
			throw new Error(`OpenAI API error: ${response.status}`);
		}
		
		const reader = response.body.getReader();
		const decoder = new TextDecoder();
		let aiResponse = '';
		const messagesContainer = document.getElementById('chat-messages');
		let isJsonResponse = false;
		
		while (true) {
			const { done, value } = await reader.read();
			if (done) break;
			
			const chunk = decoder.decode(value);
			const lines = chunk.split('\n').filter(line => line.trim() !== '');
			
			for (const line of lines) {
				if (line.startsWith('data: ')) {
					const data = line.slice(6);
					if (data === '[DONE]') continue;
					
					try {
						const parsed = JSON.parse(data);
						const content = parsed.choices[0]?.delta?.content;
						if (content) {
							aiResponse += content;
							
							// Check if response looks like JSON (contains actions)
							if (aiResponse.includes('"actions"') || aiResponse.trim().startsWith('{')) {
								isJsonResponse = true;
								// Keep showing dots, don't stream JSON
								messageDiv.textContent = '...';
							} else {
								// Stream normal conversation text
								messageDiv.textContent = aiResponse;
							}
							messagesContainer.scrollTop = messagesContainer.scrollHeight;
						}
					} catch (e) {
						// Skip malformed JSON
					}
				}
			}
		}
		
		// Try to parse JSON response
		try {
			const parsed = JSON.parse(aiResponse);
			// Don't show message yet, let executeAIAction handle it
			return parsed;
		} catch (e) {
			// If not JSON, it's already displayed
			return { message: aiResponse, actions: [] };
		}
	} catch (error) {
		console.error('OpenAI API Error:', error);
		throw error;
	}
}

// Timezone conversion utilities
function convertLocalToUTC(localDateTimeString) {
	// Takes a datetime string like "2025-12-11T16:00:00" in user's local timezone
	// Returns ISO string in UTC for database storage
	const localDate = new Date(localDateTimeString);
	return localDate.toISOString();
}

function convertUTCToLocal(utcDateTimeString) {
	// Takes UTC datetime string from database
	// Returns formatted local datetime for FullCalendar
	return utcDateTimeString; // FullCalendar handles this automatically
}

async function executeAIAction(action) {
	try {
		if (action.type === 'create_event') {
			const eventData = {
				...action.data,
				start: convertLocalToUTC(action.data.start),
				end: convertLocalToUTC(action.data.end)
			};
			const savedEvent = await window.saveEventToSupabase(eventData);
			
			// Refresh calendar
			if (window.calendar) {
				window.calendar.refetchEvents();
			}
			if (window.refreshMiniCalendar) {
				window.refreshMiniCalendar();
			}
			
			return { success: true };
		} else if (action.type === 'create_recurring_event') {
			const { recurrence, ...baseEventData } = action.data;
			// Convert base times to UTC before generating recurrences
			const baseWithUTC = {
				...baseEventData,
				start: action.data.start,
				end: action.data.end
			};
			const events = generateRecurringEvents(baseWithUTC, recurrence);
			
			// Create all events with same series_id
			for (const event of events) {
				await window.saveEventToSupabase(event);
			}
			
			// Refresh calendar
			if (window.calendar) {
				window.calendar.refetchEvents();
			}
			if (window.refreshMiniCalendar) {
				window.refreshMiniCalendar();
			}
			
			return { success: true };
		} else if (action.type === 'create_todo') {
			const todoData = action.data;
			await window.saveTodoToSupabase(todoData);
			
			// Refresh todos
			await loadTodos();
			if (window.refreshMiniCalendar) {
				window.refreshMiniCalendar();
			}
			
			return { success: true };
		} else if (action.type === 'delete_event') {
			await window.deleteEventFromSupabase(action.eventId);
			
			if (window.calendar) {
				const event = window.calendar.getEventById(action.eventId);
				if (event) event.remove();
			}
			if (window.refreshMiniCalendar) {
				window.refreshMiniCalendar();
			}
			
			return { success: true };
		} else if (action.type === 'delete_todo') {
			await window.deleteTodoFromSupabase(action.todoId);
			await loadTodos();
			if (window.refreshMiniCalendar) {
				window.refreshMiniCalendar();
			}
			
			return { success: true };
		}
		return { success: true };
	} catch (error) {
		console.error('Action execution error:', error);
		return { success: false, error: error.message };
	}
}

// Initialize sidebar state
document.addEventListener('DOMContentLoaded', async function() {
	// Check authentication first
	const isAuthenticated = await window.requireAuth();
	if (!isAuthenticated) {
		return; // requireAuth will redirect to login page
	}

	// Get user info and display
	try {
		const user = await window.getCurrentUser();
		const profile = await window.getUserProfile();
		
		if (profile) {
			console.log('User profile loaded:', profile);
			// Display user info in the UI
			const userDisplay = document.querySelector('.user-display');
			if (userDisplay) {
				const nameSpan = userDisplay.querySelector('span:first-child');
				const uniSpan = userDisplay.querySelector('span:last-child');
				
				if (nameSpan) {
					nameSpan.textContent = `${profile.first_name} ${profile.last_name}`;
				}
				if (uniSpan) {
					uniSpan.textContent = profile.university;
				}
			}
		}
	} catch (error) {
		console.error('Failed to load user profile:', error);
		// Show error state in UI
		const userDisplay = document.querySelector('.user-display');
		if (userDisplay) {
			const nameSpan = userDisplay.querySelector('span:first-child');
			if (nameSpan) {
				nameSpan.textContent = 'Error loading profile';
			}
		}
	}

	// Add logout button handler
	const logoutBtn = document.getElementById('logout-btn');
	if (logoutBtn) {
		logoutBtn.addEventListener('click', async () => {
			if (confirm('Are you sure you want to sign out?')) {
				const result = await window.signOut();
				if (result.success) {
					window.location.href = 'login.html';
				} else {
					alert('Failed to sign out. Please try again.');
				}
			}
		});
	}

	// Initialize right menu as visible by default (remove right-menu-hidden class if present)
	const fantastical = document.querySelector('.fantastical');
	if (fantastical) {
		fantastical.classList.remove('right-menu-hidden');
	}
	
	// Load todos from Supabase
	console.log('About to call loadTodos()...');
	await loadTodos();
	console.log('loadTodos() completed');
	
	// Initialize chat input Enter key support
	const chatInput = document.getElementById('chat-input');
	if (chatInput) {
		chatInput.addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				e.preventDefault();
				sendMessage();
			}
		});
	}
	
	// Add keyboard shortcut (Ctrl/Cmd + B) to toggle sidebar
	document.addEventListener('keydown', function(e) {
		if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
			e.preventDefault();
			toggleSidebar();
		}
		// Add keyboard shortcut (Ctrl/Cmd + R) to toggle right menu
		if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
			e.preventDefault();
			toggleRightMenu();
		}
	});
	
	// Listen for window resize to update calendar
	let resizeTimeout;
	window.addEventListener('resize', function() {
		if (window.calendar) {
			// Debounce resize events for better performance
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(() => {
				window.calendar.updateSize();
				// Force complete recalculation
				requestAnimationFrame(() => {
					window.calendar.updateSize();
				});
			}, 100);
		}
	});
});

// Event Modal Functions
let currentEventId = null;

function showToast(message, type = 'success') {
	const toast = document.createElement('div');
	toast.className = `toast ${type}`;
	toast.textContent = message;
	document.body.appendChild(toast);
	
	setTimeout(() => {
		toast.remove();
	}, 5000);
}

function updateColorPicker(selectedColor, colorName = '') {
	const colorOptions = document.querySelectorAll('.color-option');
	let name = colorName;
	
	colorOptions.forEach(option => {
		if (option.dataset.color === selectedColor) {
			option.classList.add('selected');
			if (!name) name = option.dataset.name || option.title;
		} else {
			option.classList.remove('selected');
		}
	});
	
	document.getElementById('event-color').value = selectedColor;
	document.getElementById('color-preview').style.backgroundColor = selectedColor;
	if (name) document.getElementById('color-name').textContent = name;
}

function openEventModal(event = null, startDate = null, endDate = null, allDay = false) {
	const modal = document.getElementById('event-modal');
	const modalTitle = document.getElementById('modal-title');
	const form = document.getElementById('event-form');
	const deleteBtn = document.getElementById('delete-event-btn');
	
	// Reset form
	form.reset();
	currentEventId = null;
	
	if (event) {
		// Edit existing event
		modalTitle.textContent = 'Edit Event';
		deleteBtn.style.display = 'block';
		currentEventId = event.id;
		
		document.getElementById('event-id').value = event.id;
		document.getElementById('event-title').value = event.title;
		document.getElementById('event-description').value = event.extendedProps?.description || '';
		document.getElementById('event-location').value = event.extendedProps?.location || '';
		const eventColor = event.backgroundColor || event.color || '#3b82f6';
		document.getElementById('event-color').value = eventColor;
		updateColorPicker(eventColor);
		document.getElementById('event-all-day').checked = event.allDay;
		
		// Format dates for datetime-local input
		const start = new Date(event.start);
		const end = new Date(event.end || event.start);
		document.getElementById('event-start').value = formatDateTimeLocal(start);
		document.getElementById('event-end').value = formatDateTimeLocal(end);
	} else {
		// Create new event
		modalTitle.textContent = 'New Event';
		deleteBtn.style.display = 'none';
		
		// Set default times
		const start = startDate || new Date();
		const end = endDate || new Date(start.getTime() + 60 * 60 * 1000); // 1 hour later
		
		document.getElementById('event-start').value = formatDateTimeLocal(start);
		document.getElementById('event-end').value = formatDateTimeLocal(end);
		document.getElementById('event-all-day').checked = allDay;
		document.getElementById('event-color').value = '#3b82f6';
		updateColorPicker('#3b82f6');
	}
	
	modal.style.display = 'flex';
}

function closeEventModal() {
	const modal = document.getElementById('event-modal');
	modal.style.display = 'none';
	currentEventId = null;
}

function formatDateTimeLocal(date) {
	const year = date.getFullYear();
	const month = String(date.getMonth() + 1).padStart(2, '0');
	const day = String(date.getDate()).padStart(2, '0');
	const hours = String(date.getHours()).padStart(2, '0');
	const minutes = String(date.getMinutes()).padStart(2, '0');
	return `${year}-${month}-${day}T${hours}:${minutes}`;
}

async function deleteEvent() {
	if (!currentEventId) return;
	
	if (!confirm('Are you sure you want to delete this event?')) {
		return;
	}
	
	try {
		await window.deleteEventFromSupabase(currentEventId);
		
		// Remove event from calendar
		const event = window.calendar.getEventById(currentEventId);
		if (event) {
			event.remove();
		}
		
		closeEventModal();
		showToast('Event deleted successfully!');
		
		// Refresh mini calendar
		if (window.refreshMiniCalendar) window.refreshMiniCalendar();
	} catch (error) {
		console.error('Error deleting event:', error);
		showToast('Failed to delete event: ' + error.message, 'error');
	}
}

// Handle form submission
document.addEventListener('DOMContentLoaded', function() {
	const form = document.getElementById('event-form');
	if (form) {
		form.addEventListener('submit', async function(e) {
			e.preventDefault();
			
			const eventData = {
				id: currentEventId,
				title: document.getElementById('event-title').value,
				description: document.getElementById('event-description').value,
				start: document.getElementById('event-start').value,
				end: document.getElementById('event-end').value,
				location: document.getElementById('event-location').value,
				color: document.getElementById('event-color').value,
				allDay: document.getElementById('event-all-day').checked
			};
			
			// Validate dates
			if (new Date(eventData.end) <= new Date(eventData.start)) {
				alert('End time must be after start time');
				return;
			}
			
			try {
				const savedEvent = await window.saveEventToSupabase(eventData);
				
				if (currentEventId) {
					// Update existing event in calendar
					const calEvent = window.calendar.getEventById(currentEventId);
					if (calEvent) {
						calEvent.setProp('title', eventData.title);
						calEvent.setStart(eventData.start);
						calEvent.setEnd(eventData.end);
						calEvent.setProp('backgroundColor', eventData.color);
						calEvent.setProp('borderColor', eventData.color);
						calEvent.setAllDay(eventData.allDay);
						calEvent.setExtendedProp('description', eventData.description);
						calEvent.setExtendedProp('location', eventData.location);
					}
				} else {
					// Add new event to calendar
					window.calendar.addEvent({
						id: savedEvent.id,
						title: eventData.title,
						start: eventData.start,
						end: eventData.end,
						allDay: eventData.allDay,
						color: eventData.color,
						extendedProps: {
							description: eventData.description,
							location: eventData.location
						}
					});
				}
				
				closeEventModal();
				showToast(currentEventId ? 'Event updated successfully!' : 'Event created successfully!');
				
				// Refresh mini calendar
				if (window.refreshMiniCalendar) window.refreshMiniCalendar();
			} catch (error) {
				console.error('Error saving event:', error);
				showToast('Failed to save event: ' + error.message, 'error');
			}
		});
	}
	
	// Color picker dropdown toggle
	const dropdownTrigger = document.getElementById('color-dropdown-trigger');
	const colorGrid = document.getElementById('color-picker-grid');
	
	if (dropdownTrigger) {
		dropdownTrigger.addEventListener('click', function(e) {
			e.stopPropagation();
			this.classList.toggle('open');
			colorGrid.classList.toggle('open');
		});
	}
	
	// Color picker event listeners
	const colorOptions = document.querySelectorAll('.color-option');
	colorOptions.forEach(option => {
		option.addEventListener('click', function() {
			const selectedColor = this.dataset.color;
			const colorName = this.dataset.name || this.title;
			updateColorPicker(selectedColor, colorName);
			// Close dropdown after selection
			dropdownTrigger.classList.remove('open');
			colorGrid.classList.remove('open');
		});
	});
	
	// Close dropdown when clicking outside
	document.addEventListener('click', function(e) {
		if (!e.target.closest('.color-dropdown')) {
			if (dropdownTrigger) dropdownTrigger.classList.remove('open');
			if (colorGrid) colorGrid.classList.remove('open');
		}
	});
	
	// Close modal when clicking outside
	const modal = document.getElementById('event-modal');
	if (modal) {
		modal.addEventListener('click', function(e) {
			if (e.target === modal) {
				closeEventModal();
			}
		});
	}
	
	// Todo modal close on outside click
	const todoModal = document.getElementById('todo-modal');
	if (todoModal) {
		todoModal.addEventListener('click', function(e) {
			if (e.target === todoModal) {
				closeTodoModal();
			}
		});
	}
	
	// Todo form submission
	const todoForm = document.getElementById('todo-form');
	if (todoForm) {
		todoForm.addEventListener('submit', async function(e) {
			e.preventDefault();
			await saveTodo();
		});
	}
	
	// Todo color picker
	const todoColorTrigger = document.getElementById('todo-color-dropdown-trigger');
	const todoColorGrid = document.getElementById('todo-color-picker-grid');
	
	if (todoColorTrigger) {
		todoColorTrigger.addEventListener('click', function(e) {
			e.stopPropagation();
			this.classList.toggle('open');
			todoColorGrid.classList.toggle('open');
		});
	}
	
	const todoColorOptions = document.querySelectorAll('#todo-color-picker-grid .color-option');
	todoColorOptions.forEach(option => {
		option.addEventListener('click', function() {
			const selectedColor = this.dataset.color;
			const colorName = this.dataset.name || this.title;
			updateTodoColorPicker(selectedColor, colorName);
			todoColorTrigger.classList.remove('open');
			todoColorGrid.classList.remove('open');
		});
	});
});

// Todo Modal Functions
let currentTodoId = null;

function openTodoModal(todo = null) {
	const modal = document.getElementById('todo-modal');
	const modalTitle = document.getElementById('todo-modal-title');
	const form = document.getElementById('todo-form');
	const deleteBtn = document.getElementById('delete-todo-btn');
	
	// Reset form
	form.reset();
	currentTodoId = null;
	
	if (todo) {
		// Edit existing todo
		modalTitle.textContent = 'Edit Todo';
		deleteBtn.style.display = 'block';
		currentTodoId = todo.id;
		
		document.getElementById('todo-id').value = todo.id;
		document.getElementById('todo-title').value = todo.title;
		document.getElementById('todo-description').value = todo.description || '';
		document.getElementById('todo-due-date').value = todo.dueDate;
		document.getElementById('todo-duration').value = todo.duration || 30;
		document.getElementById('todo-category').value = todo.category || '';
		document.getElementById('todo-priority').value = todo.priority || 3;
		const todoColor = todo.color || '#3b82f6';
		document.getElementById('todo-color').value = todoColor;
		updateTodoColorPicker(todoColor);
	} else {
		// Create new todo
		modalTitle.textContent = 'New Todo';
		deleteBtn.style.display = 'none';
		
		// Set default due date to today
		const today = new Date().toISOString().split('T')[0];
		document.getElementById('todo-due-date').value = today;
		document.getElementById('todo-duration').value = 30;
		document.getElementById('todo-priority').value = 3;
		document.getElementById('todo-color').value = '#3b82f6';
		updateTodoColorPicker('#3b82f6');
	}
	
	modal.style.display = 'flex';
}

function closeTodoModal() {
	const modal = document.getElementById('todo-modal');
	modal.style.display = 'none';
	currentTodoId = null;
}

function updateTodoColorPicker(selectedColor, colorName = '') {
	const colorOptions = document.querySelectorAll('#todo-color-picker-grid .color-option');
	let name = colorName;
	
	colorOptions.forEach(option => {
		if (option.dataset.color === selectedColor) {
			option.classList.add('selected');
			if (!name) name = option.dataset.name || option.title;
		} else {
			option.classList.remove('selected');
		}
	});
	
	document.getElementById('todo-color').value = selectedColor;
	document.getElementById('todo-color-preview').style.backgroundColor = selectedColor;
	if (name) document.getElementById('todo-color-name').textContent = name;
}

async function saveTodo() {
	const todoData = {
		id: currentTodoId,
		title: document.getElementById('todo-title').value,
		description: document.getElementById('todo-description').value,
		dueDate: document.getElementById('todo-due-date').value,
		duration: parseInt(document.getElementById('todo-duration').value) || 30,
		category: document.getElementById('todo-category').value.toUpperCase(),
		priority: parseInt(document.getElementById('todo-priority').value) || 3,
		color: document.getElementById('todo-color').value,
		completed: false
	};
	
	try {
		const savedTodo = await window.saveTodoToSupabase(todoData);
		
		closeTodoModal();
		showToast(currentTodoId ? 'Todo updated successfully!' : 'Todo created successfully!');
		
		// Reload todos to update the sidebar
		await loadTodos();
		
		// Refresh mini calendar
		if (window.refreshMiniCalendar) window.refreshMiniCalendar();
	} catch (error) {
		console.error('Error saving todo:', error);
		showToast('Failed to save todo: ' + error.message, 'error');
	}
}

async function deleteTodo() {
	if (!currentTodoId) return;
	
	if (!confirm('Are you sure you want to delete this todo?')) {
		return;
	}
	
	try {
		await window.deleteTodoFromSupabase(currentTodoId);
		
		closeTodoModal();
		showToast('Todo deleted successfully!');
		
		// Reload todos to update the sidebar
		await loadTodos();
		
		// Refresh mini calendar
		if (window.refreshMiniCalendar) window.refreshMiniCalendar();
	} catch (error) {
		console.error('Error deleting todo:', error);
		showToast('Failed to delete todo: ' + error.message, 'error');
	}
}
</script>
</body>
</html>
